<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fast Photo FX ‚Äî Lightweight</title>
<style>
  :root{
    --bg1:#0f172a; --bg2:#022c43; --card:#0b1220;
    --accent:#ff6b6b; --muted:#9aa8b2; --glass: rgba(255,255,255,0.04);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    font-family:Inter,system-ui,Arial;
    background: linear-gradient(180deg,var(--bg1),var(--bg2));
    color:#e6eef6;
    padding:18px;
  }
  .app {
    width:100%;
    max-width:980px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:14px;
    padding:18px;
    box-shadow: 0 10px 30px rgba(2,12,27,0.6);
  }
  header{
    display:flex;gap:12px;align-items:center;margin-bottom:14px;
  }
  h1{font-size:20px;margin:0}
  p.small { margin:0;color:var(--muted); font-size:13px}

  .toprow{
    display:flex;gap:12px;flex-wrap:wrap;margin:10px 0 18px;
    align-items:center;
  }

  /* upload button */
  .upload-wrap{
    display:flex;gap:12px;align-items:center;
  }
  input[type=file]{display:none}
  .btn{
    background:linear-gradient(90deg,var(--accent),#ff8f70);
    border:none;color:#081020;padding:10px 14px;border-radius:12px;font-weight:700;
    cursor:pointer;box-shadow: 0 6px 18px rgba(255,107,107,0.18);
  }
  .ghost {
    background:transparent;border:1px solid rgba(255,255,255,0.06);
    color:var(--muted); padding:8px 12px;border-radius:10px;cursor:pointer;
  }

  /* canvas area */
  .workspace{
    display:flex;gap:16px;flex-wrap:wrap;
    align-items:flex-start;
  }
  .preview {
    flex:1 1 460px;
    background:var(--card);
    border-radius:12px;
    padding:12px;
    display:flex;
    justify-content:center;
    align-items:center;
    min-height:360px;
    max-height:720px;
    overflow:hidden;
  }
  canvas{ max-width:100%; border-radius:10px; display:block; background:#222; }

  /* effects pane */
  .effects {
    width:320px;
    max-width:100%;
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
    border-radius:12px;padding:12px;
  }
  .effects h3{margin:4px 0 10px;font-size:15px}
  .effect-grid{
    display:grid;
    grid-template-columns: repeat(2, 1fr);
    gap:10px;
  }
  .ef{
    background:var(--glass);
    border-radius:10px;padding:10px;cursor:pointer;
    border:1px solid rgba(255,255,255,0.02);text-align:center;
    transition:transform .14s, box-shadow .14s, background .14s;
    font-weight:700;color:#eaf4ff;
  }
  .ef:active{transform:translateY(2px)}
  .ef:hover{box-shadow:0 8px 20px rgba(0,0,0,0.45); background: rgba(255,255,255,0.02)}
  .ef.small{font-size:13px;padding:8px}

  .actions{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
  .note{font-size:12px;color:var(--muted);margin-top:10px}

  footer{margin-top:12px;color:var(--muted);font-size:13px}
  @media(max-width:880px){
    .workspace { flex-direction:column; }
    .effects{width:100%}
  }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Photo effects">
    <header>
      <div>
        <h1>Fast Photo FX</h1>
        <p class="small">Upload ‚Üí pick one-click effect ‚Üí Save. Optimized for low-lag on mobile.</p>
      </div>
    </header>

    <div class="toprow">
      <div class="upload-wrap">
        <label class="btn" for="fileInput">üìÅ Choose Photo</label>
        <input id="fileInput" type="file" accept="image/*">
        <button id="resetBtn" class="ghost">Reset</button>
      </div>

      <div style="margin-left:auto; display:flex; gap:8px;">
        <button id="saveBtn" class="btn">üíæ Save</button>
        <button id="downloadSmall" class="ghost">Save smaller</button>
      </div>
    </div>

    <div class="workspace">
      <div class="preview" aria-live="polite">
        <canvas id="canvas" width="640" height="480"></canvas>
      </div>

      <aside class="effects" aria-label="Effects list">
        <h3>One-click Effects</h3>
        <div class="effect-grid" id="effectsGrid">
          <!-- Buttons generated by JS -->
        </div>

        <div class="actions" style="margin-top:10px;">
          <button id="undo" class="ef small">Undo</button>
          <button id="redo" class="ef small">Redo</button>
        </div>

        <p class="note">Tip: If your phone is older, use "Save smaller" to make downloads faster.</p>
      </aside>
    </div>

    <footer>Made for Acode ‚Äî optimized to avoid freezing. Max processing size: <span id="sizeInfo">800√ó800</span></footer>
  </div>

<script>
/* ---------------------------
  Fast Photo FX ‚Äî Lightweight
  - Resizes input to MAX_DIM for processing (to avoid lag)
  - 12 one-click effects: simple filter + a few canvas pixel operations
  - Uses canvas.toBlob() for saving (low memory)
  - Undo/Redo (one level)
----------------------------*/
const MAX_DIM = 800; // processing max size (keeps memory low)
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const fileInput = document.getElementById('fileInput');
const effectsGrid = document.getElementById('effectsGrid');
const saveBtn = document.getElementById('saveBtn');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undo');
const redoBtn = document.getElementById('redo');
const downloadSmall = document.getElementById('downloadSmall');
const sizeInfo = document.getElementById('sizeInfo');

let originalImage = null;      // Image object at processing size
let history = { undo: null, redo: null }; // one-step history

// Effects list (id, label, function)
const EFFECTS = [
  { id: 'none', label: 'No effect', apply: imgFilter_none },
  { id: 'grayscale', label: 'Grayscale', apply: imgFilter_css('grayscale(100%)') },
  { id: 'sepia', label: 'Sepia', apply: imgFilter_css('sepia(100%)') },
  { id: 'invert', label: 'Invert', apply: imgFilter_css('invert(100%)') },
  { id: 'blur', label: 'Blur', apply: imgFilter_css('blur(4px)') },
  { id: 'bright', label: 'Bright +', apply: imgFilter_css('brightness(1.35)') },
  { id: 'contrast', label: 'High Contrast', apply: imgFilter_css('contrast(1.6)') },
  { id: 'saturate', label: 'Saturate', apply: imgFilter_css('saturate(1.8)') },
  { id: 'vintage', label: 'Vintage Hue', apply: imgFilter_css('hue-rotate(25deg) sepia(20%) contrast(1.1)') },
  { id: 'pixelate', label: 'Pixelate', apply: imgOp_pixelate },
  { id: 'posterize', label: 'Posterize', apply: imgOp_posterize },
  { id: 'sharpen', label: 'Sharpen', apply: imgOp_sharpen }
];

// build effect buttons
EFFECTS.forEach(e => {
  const b = document.createElement('button');
  b.className = 'ef';
  b.textContent = e.label;
  b.title = e.label;
  b.addEventListener('click', async () => {
    if (!originalImage) { alert('Upload a photo first'); return; }
    // save undo state
    history.undo = canvas.toDataURL('image/png');
    history.redo = null;
    await applyEffect(e.apply);
  });
  effectsGrid.appendChild(b);
});

// file upload handler (resize to MAX_DIM)
fileInput.addEventListener('change', async (ev) => {
  const file = ev.target.files[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = () => {
    // resize to max dimension
    const { w, h } = fitSize(img.width, img.height, MAX_DIM);
    canvas.width = w; canvas.height = h;
    // draw into canvas with smoothing for good quality
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img, 0,0, w, h);
    originalImage = new Image();
    originalImage.src = canvas.toDataURL('image/png');
    // reset history
    history.undo = null; history.redo = null;
    URL.revokeObjectURL(url);
  };
  img.onerror = () => { alert('Unable to read image'); URL.revokeObjectURL(url); };
  img.src = url;
});

// Reset button ‚Äî restore original (processing-size) image
resetBtn.addEventListener('click', () => {
  if (!originalImage) return;
  history.undo = canvas.toDataURL('image/png');
  history.redo = null;
  originalImage.onload = () => {
    canvas.width = originalImage.width; canvas.height = originalImage.height;
    ctx.filter = 'none';
    ctx.drawImage(originalImage,0,0);
  };
  originalImage.src = originalImage.src; // trigger onload if already loaded
});

// Undo / Redo simple
undoBtn.addEventListener('click', () => {
  if (!history.undo) { alert('Nothing to undo'); return; }
  history.redo = canvas.toDataURL('image/png');
  loadDataUrlIntoCanvas(history.undo);
  history.undo = null;
});
redoBtn.addEventListener('click', () => {
  if (!history.redo) { alert('Nothing to redo'); return; }
  history.undo = canvas.toDataURL('image/png');
  loadDataUrlIntoCanvas(history.redo);
  history.redo = null;
});

// Save (full-size processed image at processing dimensions)
saveBtn.addEventListener('click', () => {
  if (!originalImage) { alert('Upload a photo first'); return; }
  canvas.toBlob((blob) => {
    if (!blob) { alert('Save failed'); return; }
    triggerDownload(blob, 'photo-fx.png');
  }, 'image/png', 0.9);
});

// Save smaller (reduces to 600px max) ‚Äî faster & smaller file
downloadSmall.addEventListener('click', () => {
  if (!originalImage) { alert('Upload a photo first'); return; }
  const smallDim = 600;
  const off = document.createElement('canvas');
  const octx = off.getContext('2d');
  const dims = fitSize(canvas.width, canvas.height, smallDim);
  off.width = dims.w; off.height = dims.h;
  // draw current canvas into offscreen scaled down
  octx.imageSmoothingQuality = 'medium';
  octx.drawImage(canvas, 0, 0, off.width, off.height);
  off.toBlob(blob => triggerDownload(blob, 'photo-fx-small.png'), 'image/jpeg', 0.85);
});

// utility: fit size to max dim
function fitSize(w,h,maxDim){
  if (w <= maxDim && h <= maxDim) return {w,h};
  const ratio = w/h;
  if (w >= h) {
    return {w: maxDim, h: Math.round(maxDim/ratio)};
  } else {
    return {w: Math.round(maxDim*ratio), h: maxDim};
  }
}

// load data URL into canvas
function loadDataUrlIntoCanvas(dataUrl){
  const img = new Image();
  img.onload = () => {
    canvas.width = img.width; canvas.height = img.height;
    ctx.filter = 'none';
    ctx.drawImage(img,0,0);
  };
  img.src = dataUrl;
}

/* --------------------------
   Effect applies
---------------------------*/
async function applyEffect(effectFn){
  // small delay allows UI to update (avoid freezing)
  await new Promise(r => setTimeout(r, 30));
  try {
    await effectFn();
  } catch (err) {
    console.error(err);
    alert('Effect failed: ' + (err.message || err));
  }
}

/* ------------- CSS-filter based wrapper ------------- */
function imgFilter_css(filterStr){
  return async function(){
    // draw original (processing-size) image then apply ctx.filter and redraw
    const base = new Image();
    base.src = originalImage ? originalImage.src : canvas.toDataURL();
    await waitForImage(base);
    canvas.width = base.width; canvas.height = base.height;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.filter = filterStr;
    ctx.drawImage(base,0,0);
    ctx.filter = 'none';
  };
}

/* --------------- simple no-op --------------- */
async function imgFilter_none(){
  if (!originalImage) return;
  const img = new Image();
  img.src = originalImage.src;
  await waitForImage(img);
  canvas.width = img.width; canvas.height = img.height;
  ctx.filter = 'none';
  ctx.drawImage(img,0,0);
}

/* --------------- Pixelate --------------- */
async function imgOp_pixelate(){
  // draw current canvas to offscreen small canvas then upscale with imageSmoothingEnabled=false
  const factor = 0.06; // smaller factor = more blocky
  const ow = Math.max(16, Math.round(canvas.width*factor)), oh = Math.max(16, Math.round(canvas.height*factor));
  const off1 = document.createElement('canvas'), off2 = document.createElement('canvas');
  off1.width = ow; off1.height = oh;
  off2.width = canvas.width; off2.height = canvas.height;
  const o1 = off1.getContext('2d'), o2 = off2.getContext('2d');
  // draw current image into off1 (downscale)
  o1.drawImage(canvas, 0,0, off1.width, off1.height);
  // upscale into off2 without smoothing
  o2.imageSmoothingEnabled = false;
  o2.drawImage(off1, 0,0, off2.width, off2.height);
  // copy to main canvas
  canvas.width = off2.width; canvas.height = off2.height;
  ctx.drawImage(off2, 0,0);
}

/* --------------- Posterize / cartoonish quantize --------------- */
async function imgOp_posterize(){
  // quantize colors to fewer levels
  const levels = 6; // smaller = more posterized
  const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
  const d = imageData.data;
  for (let i=0;i<d.length;i+=4){
    d[i] = Math.round(d[i] / 255 * (levels-1)) * (255/(levels-1));
    d[i+1] = Math.round(d[i+1] / 255 * (levels-1)) * (255/(levels-1));
    d[i+2] = Math.round(d[i+2] / 255 * (levels-1)) * (255/(levels-1));
  }
  ctx.putImageData(imageData,0,0);
}

/* --------------- Sharpen (convolution) --------------- */
async function imgOp_sharpen(){
  // mild sharpen kernel
  const kernel = [
    0, -1, 0,
    -1, 5, -1,
    0, -1, 0
  ];
  convolution(kernel, 3);
}

// convolution helper
function convolution(kernel, size){
  const w = canvas.width, h = canvas.height;
  const src = ctx.getImageData(0,0,w,h);
  const dst = ctx.createImageData(w,h);
  const d = dst.data, s = src.data;
  const half = Math.floor(size/2);
  for (let y=0;y<h;y++){
    for (let x=0;x<w;x++){
      let r=0,g=0,b=0,a=0;
      for (let ky=0; ky<size; ky++){
        for (let kx=0; kx<size; kx++){
          const ix = x + kx - half;
          const iy = y + ky - half;
          if (ix>=0 && ix<w && iy>=0 && iy<h){
            const idx = (iy*w + ix)*4;
            const kval = kernel[ky*size + kx];
            r += s[idx]*kval;
            g += s[idx+1]*kval;
            b += s[idx+2]*kval;
            a += s[idx+3]*kval;
          }
        }
      }
      const di = (y*w + x)*4;
      d[di] = clamp(Math.round(r));
      d[di+1] = clamp(Math.round(g));
      d[di+2] = clamp(Math.round(b));
      d[di+3] = clamp(Math.round(a));
    }
  }
  ctx.putImageData(dst,0,0);
}
function clamp(v){ return Math.max(0, Math.min(255, v)); }

/* -------------- helpers -------------- */
function waitForImage(img){
  return new Promise((res, rej) => {
    if (img.complete && img.naturalWidth) return res();
    img.onload = () => res();
    img.onerror = () => rej(new Error('Image load error'));
  });
}

function triggerDownload(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  // add to DOM for some Android browsers
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1500);
}

/* small init: show default canvas hint */
ctx.font = '16px system-ui';
ctx.fillStyle = '#bcd6ff';
ctx.textAlign = 'center';
ctx.fillText('Choose a photo to start', canvas.width/2 || 320, canvas.height/2 || 200);

// update displayed size info
sizeInfo.textContent = `${MAX_DIM}√ó${MAX_DIM}`;

</script>
</body>
</html>